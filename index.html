<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"palmbeach.gitee.io","root":"/","scheme":"Mist","version":"8.0.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="PALM BEACH">
<meta property="og:url" content="https://palmbeach.gitee.io/index.html">
<meta property="og:site_name" content="PALM BEACH">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://palmbeach.gitee.io/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>PALM BEACH</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">PALM BEACH</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://palmbeach.gitee.io/2020/11/23/windows%20%E9%80%9A%E8%BF%87%E6%9C%89%E7%BA%BF%E5%85%B1%E4%BA%AB%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PALM BEACH">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/windows%20%E9%80%9A%E8%BF%87%E6%9C%89%E7%BA%BF%E5%85%B1%E4%BA%AB%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">windows 通过有线共享网络</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-23 15:22:26" itemprop="dateCreated datePublished" datetime="2020-11-23T15:22:26+08:00">2020-11-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="问题：-目前有两台电脑，还有一个无线WIFI热点，一个电脑有无线网卡，另一个没有，如何使两个电脑同时上网？"><a href="#问题：-目前有两台电脑，还有一个无线WIFI热点，一个电脑有无线网卡，另一个没有，如何使两个电脑同时上网？" class="headerlink" title="问题： 目前有两台电脑，还有一个无线WIFI热点，一个电脑有无线网卡，另一个没有，如何使两个电脑同时上网？"></a>问题： 目前有两台电脑，还有一个无线WIFI热点，一个电脑有无线网卡，另一个没有，如何使两个电脑同时上网？</h5><p>解决方案：</p>
<ul>
<li>电脑A同时具备无线网卡和有线网卡，电脑B只有有线网卡，右键电脑A的无线网卡属性，找到共享选项卡，勾选允许通过此计算机的Internet连接</li>
<li>这时候查看有线网卡，IP4中自动设置了IP地址为192.168.137.1，首选DNS设置为无线网卡的IP地址</li>
<li>电脑B的IP地址设置为自动获取，这时候就完成了两个电脑同时上网</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/06/23/NNMXUf.png" alt="NNMXUf.png"></p>
<p><img src="https://s1.ax1x.com/2020/06/23/NNQpvj.png" alt="NNQpvj.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://palmbeach.gitee.io/2020/11/23/JWTtoken%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PALM BEACH">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/JWTtoken%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6/" class="post-title-link" itemprop="url">JWT token机制研究</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-11-23 14:15:28 / Modified: 14:53:06" itemprop="dateCreated datePublished" datetime="2020-11-23T14:15:28+08:00">2020-11-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT?"></a>什么是JWT?</h4><p>JWT(json web token)， 是基于<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3adfc2f8e15f#">RFC7519</a>定义的实现双方传输可信数据的安全机制。打个比方：JWT是有领导签字的文书，因为有领导签字，所以我确定对方是合法的，不是别人冒充的。那如何确认这个签字是合法的呢？这个涉及到JWT的签名机制，下面会详细讨论。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/11/23/JWTtoken%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://palmbeach.gitee.io/2020/11/23/MyBatis%E4%BD%BF%E7%94%A8association%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%AF%B9%E4%B8%80%E7%BA%A7%E8%81%94%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A1%88%E4%BE%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PALM BEACH">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/MyBatis%E4%BD%BF%E7%94%A8association%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%AF%B9%E4%B8%80%E7%BA%A7%E8%81%94%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A1%88%E4%BE%8B/" class="post-title-link" itemprop="url">MyBatis使用association实现一对一级联查询的几种案例</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-11-23 14:11:39 / Modified: 14:53:06" itemprop="dateCreated datePublished" datetime="2020-11-23T14:11:39+08:00">2020-11-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MyBatis使用association实现一对一级联查询的几种案例"><a href="#MyBatis使用association实现一对一级联查询的几种案例" class="headerlink" title="MyBatis使用association实现一对一级联查询的几种案例"></a>MyBatis使用association实现一对一级联查询的几种案例</h1><p>我们平日经常会遇到需要级联查询的场景，这里通过案例给大家展示实现过程。我们要查询的用户信息里面有个角色信息，一个用户对应一个角色，我们现在要求查出用户信息的同时，关联查出用户的角色信息，那么这个时候我们可以通过级联属性的方式，将角色中的数据查出来封装到用户User的role属性里面，我们还有另外一种方式来实现数据的封装。接下来我们将介绍一下association标签的相关用法，包括<strong>嵌套查询</strong>和<strong>分段查询</strong>两种方式。</p>
<p>准备工作：</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/11/23/MyBatis%E4%BD%BF%E7%94%A8association%E5%AE%9E%E7%8E%B0%E4%B8%80%E5%AF%B9%E4%B8%80%E7%BA%A7%E8%81%94%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A1%88%E4%BE%8B/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://palmbeach.gitee.io/2020/11/23/linux%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PALM BEACH">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/linux%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">linux笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-11-23 14:10:58 / Modified: 14:53:06" itemprop="dateCreated datePublished" datetime="2020-11-23T14:10:58+08:00">2020-11-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-编译通过，运行时提示找不到库文件"><a href="#1-编译通过，运行时提示找不到库文件" class="headerlink" title="1 编译通过，运行时提示找不到库文件"></a>1 编译通过，运行时提示找不到库文件</h2><pre><code>libglog.so.0: cannot open shared object file: No such file or directory</code></pre>
<p>dconfig是一个动态链接库管理命令，其目的为了让动态链接库为系统所共享。<br>ldconfig的主要用途：<br>默认搜寻/lilb和/usr/lib，以及配置文件/etc/ld.so.conf内所列的目录下的库文件。<br>搜索出可共享的动态链接库，库文件的格式为：lib***.so.**，进而创建出动态装入程序(ld.so)所需的连接和缓存文件。<br>缓存文件默认为/etc/ld.so.cache，该文件保存已排好序的动态链接库名字列表。<br>ldconfig通常在系统启动时运行，而当用户安装了一个新的动态链接库时，就需要手工运行这个命令。</p>
<h1 id="一-安装配置mysql数据库"><a href="#一-安装配置mysql数据库" class="headerlink" title="一 安装配置mysql数据库"></a>一 安装配置mysql数据库</h1><h2 id="1-安装MySQL"><a href="#1-安装MySQL" class="headerlink" title="1.安装MySQL"></a>1.安装MySQL</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/11/23/linux%E7%AC%94%E8%AE%B0/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://palmbeach.gitee.io/2020/11/23/knife4j--Swagger%E7%94%9F%E6%88%90Api%E6%96%87%E6%A1%A3%E7%9A%84%E5%A2%9E%E5%BC%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PALM BEACH">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/knife4j--Swagger%E7%94%9F%E6%88%90Api%E6%96%87%E6%A1%A3%E7%9A%84%E5%A2%9E%E5%BC%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">knife4j--Swagger生成Api文档的增强解决方案</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-11-23 14:10:30 / Modified: 14:53:06" itemprop="dateCreated datePublished" datetime="2020-11-23T14:10:30+08:00">2020-11-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <hr>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案,前身是swagger-bootstrap-ui,取名kni4j是希望它能像一把匕首一样小巧,轻量,并且功能强悍!</p>
<blockquote>
<p>Knife4j提供导出4种格式的离线文档(Html\Markdown\Word\Pdf)</p>
</blockquote>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/11/23/knife4j--Swagger%E7%94%9F%E6%88%90Api%E6%96%87%E6%A1%A3%E7%9A%84%E5%A2%9E%E5%BC%BA%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://palmbeach.gitee.io/2020/11/23/BlockingQueue%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PALM BEACH">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/BlockingQueue%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">BlockingQueue及其实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-11-23 11:12:23 / Modified: 14:53:06" itemprop="dateCreated datePublished" datetime="2020-11-23T11:12:23+08:00">2020-11-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>BlockingQueue即阻塞队列，它是基于ReentrantLock，依据它的基本原理，我们可以实现Web中的长连接聊天功能，当然其最常用的还是用于实现生产者与消费者模式，大致如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4180398-89f0d2693361656e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/873/format/webp" alt="img"></p>
<blockquote>
<p>在Java中，BlockingQueue是一个接口，它的实现类有ArrayBlockingQueue、DelayQueue、 LinkedBlockingDeque、LinkedBlockingQueue、PriorityBlockingQueue、SynchronousQueue等，它们的区别主要体现在存储结构上或对元素操作上的不同，但是对于take与put操作的原理，却是类似的。</p>
</blockquote>
<h1 id="2-阻塞与非阻塞"><a href="#2-阻塞与非阻塞" class="headerlink" title="2. 阻塞与非阻塞"></a>2. 阻塞与非阻塞</h1><h2 id="入队"><a href="#入队" class="headerlink" title="入队"></a><strong>入队</strong></h2><blockquote>
<p>offer(E e)：如果队列没满，立即返回true； 如果队列满了，立即返回false–&gt;不阻塞</p>
<p>put(E e)：如果队列满了，一直阻塞，直到队列不满了或者线程被中断–&gt;阻塞</p>
<p>offer(E e, long timeout, TimeUnit unit)：在队尾插入一个元素,，如果队列已满，则进入等待，直到出现以下三种情况：–&gt;阻塞</p>
<p>被唤醒</p>
<p>等待时间超时</p>
<p>当前线程被中断</p>
</blockquote>
<h2 id="出队"><a href="#出队" class="headerlink" title="出队"></a><strong>出队</strong></h2><blockquote>
<p>poll()：如果没有元素，直接返回null；如果有元素，出队</p>
<p>take()：如果队列空了，一直阻塞，直到队列不为空或者线程被中断–&gt;阻塞</p>
<p>poll(long timeout, TimeUnit unit)：如果队列不空，出队；如果队列已空且已经超时，返回null；如果队列已空且时间未超时，则进入等待，直到出现以下三种情况：</p>
<p>被唤醒</p>
<p>等待时间超时</p>
<p>当前线程被中断</p>
</blockquote>
<h1 id="3-LinkedBlockingQueue-源码分析"><a href="#3-LinkedBlockingQueue-源码分析" class="headerlink" title="3. LinkedBlockingQueue 源码分析"></a>3. LinkedBlockingQueue 源码分析</h1><p>LinkedBlockingQueue是一个基于链表实现的可选容量的阻塞队列。队头的元素是插入时间最长的，队尾的元素是最新插入的。新的元素将会被插入到队列的尾部。 </p>
<p>LinkedBlockingQueue的容量限制是可选的，如果在初始化时没有指定容量，那么默认使用int的最大值作为队列容量。</p>
<h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a><strong>底层数据结构</strong></h2><p>LinkedBlockingQueue内部是使用链表实现一个队列的，但是却有别于一般的队列，在于该队列至少有一个节点，头节点不含有元素。结构图如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4180398-d987601194c3e199.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/835/format/webp" alt="img"></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h2><p>LinkedBlockingQueue中维持两把锁，一把锁用于入队，一把锁用于出队，这也就意味着，同一时刻，只能有一个线程执行入队，其余执行入队的线程将会被阻塞；同时，可以有另一个线程执行出队，其余执行出队的线程将会被阻塞。换句话说，虽然入队和出队两个操作同时均只能有一个线程操作，但是可以一个入队线程和一个出队线程共同执行，也就意味着可能同时有两个线程在操作队列，那么为了维持线程安全，LinkedBlockingQueue使用一个AtomicInterger类型的变量表示当前队列中含有的元素个数，所以可以确保两个线程之间操作底层队列是线程安全的。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>LinkedBlockingQueue可以指定容量，内部维持一个队列，所以有一个头节点head和一个尾节点last，内部维持两把锁，一个用于入队，一个用于出队，还有锁关联的Condition对象。主要对象的定义如下：</p>
<blockquote>
<p>//容量，如果没有指定，该值为Integer.MAX_VALUE;</p>
<p>private final int capacity;</p>
<p>//当前队列中的元素</p>
<p>private final AtomicInteger count =new AtomicInteger();</p>
<p>//队列头节点，始终满足head.item==null</p>
<p>transient Node head;</p>
<p>//队列的尾节点，始终满足last.next==null</p>
<p>private transient Node last;</p>
<p>//用于出队的锁</p>
<p>private final ReentrantLock takeLock =new ReentrantLock();</p>
<p>//当队列为空时，保存执行出队的线程</p>
<p>private final Condition notEmpty = takeLock.newCondition();</p>
<p>//用于入队的锁</p>
<p>private final ReentrantLock putLock =new ReentrantLock();</p>
<p>//当队列满时，保存执行入队的线程</p>
<p>private final Condition notFull = putLock.newCondition();</p>
</blockquote>
<h3 id="put-E-e-方法"><a href="#put-E-e-方法" class="headerlink" title="put(E e)方法"></a>put(E e)方法</h3><p>put(E e)方法用于将一个元素插入到队列的尾部，其实现如下：</p>
<blockquote>
<p>public void put(E e)throws InterruptedException {</p>
<p>//不允许元素为null</p>
<p>  if (e ==null)</p>
<p>throw new NullPointerException();</p>
<p>  int c = -1;</p>
<p>  //以当前元素新建一个节点</p>
<p>  Node node =new Node(e);</p>
<p>  final ReentrantLock putLock =this.putLock;</p>
<p>  final AtomicInteger count =this.count;</p>
<p>  //获得入队的锁</p>
<p>  putLock.lockInterruptibly();</p>
<p>  try {</p>
<p>​    //如果队列已满，那么将该线程加入到Condition的等待队列中</p>
<p>​    while (count.get() == capacity) {</p>
<p>​       notFull.await();</p>
<p>​    }</p>
<p>​    //将节点入队</p>
<p>​    enqueue(node);</p>
<p>​    //得到插入之前队列的元素个数</p>
<p>​    c = count.getAndIncrement();</p>
<p>​    //如果还可以插入元素，那么释放等待的入队线程</p>
<p>​    if (c +1 &lt; capacity){</p>
<p>​       notFull.signal();</p>
<p>​    }</p>
<p>}finally {</p>
<p>//解锁</p>
<p>​    putLock.unlock();</p>
<p>  }</p>
<p>//通知出队线程队列非空</p>
<p>  if (c ==0)</p>
<p>signalNotEmpty();</p>
<p>}</p>
</blockquote>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><strong>3.1 具体入队与出队的原理图</strong>：</p>
<p>图中每一个节点前半部分表示封装的数据x，后边的表示指向的下一个引用。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4180398-ccb29b29b48e6192.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/132/format/webp" alt="img"></p>
<p>初始化之后，初始化一个数据为null，且head和last节点都是这个节点。</p>
<p><strong>3.2、入队两个元素过后</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4180398-0d6b2ff6b3444abf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/436/format/webp" alt="img"></p>
<p><strong>3.3、出队一个元素后</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/4180398-b482b1f470e2ad3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/283/format/webp" alt="img"></p>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="put方法总结："><a href="#put方法总结：" class="headerlink" title="put方法总结："></a>put方法总结：</h4><p>\1. LinkedBlockingQueue不允许元素为null。 </p>
<p>\2. 同一时刻，只能有一个线程执行入队操作，因为putLock在将元素插入到队列尾部时加锁了 </p>
<p>\3. 如果队列满了，那么将会调用notFull的await()方法将该线程加入到Condition等待队列中。await()方法就会释放线程占有的锁，这将导致之前由于被锁阻塞的入队线程将会获取到锁，执行到while循环处，不过可能因为由于队列仍旧是满的，也被加入到条件队列中。 </p>
<p>\4. 一旦一个出队线程取走了一个元素，并通知了入队等待队列中可以释放线程了，那么第一个加入到Condition队列中的将会被释放，那么该线程将会重新获得put锁，继而执行enqueue()方法，将节点插入到队列的尾部 </p>
<p>\5. 然后得到插入一个节点之前的元素个数，如果队列中还有空间可以插入，那么就通知notFull条件的等待队列中的线程。 </p>
<p>\6. 通知出队线程队列为空了，因为插入一个元素之前的个数为0，而插入一个之后队列中的元素就从无变成了有，就可以通知因队列为空而阻塞的出队线程了。</p>
<h2 id="E-take-方法"><a href="#E-take-方法" class="headerlink" title="E take()方法"></a>E take()方法</h2><p>take()方法用于得到队头的元素，在队列为空时会阻塞，知道队列中有元素可取。其实现如下：</p>
<blockquote>
<p>public E take() throws InterruptedException {</p>
<p>​    E x;</p>
<p>​    int c = -1;</p>
<p>​    final AtomicInteger count = this.count;</p>
<p>​    final ReentrantLock takeLock = this.takeLock;</p>
<p>​    //获取takeLock锁    </p>
<p>​     takeLock.lockInterruptibly();</p>
<p>​    try {</p>
<p>​      //如果队列为空，那么加入到notEmpty条件的等待队列中      </p>
<p>​      while (count.get() == 0) {</p>
<p>​        notEmpty.await();</p>
<p>​      }</p>
<p>​      //得到队头元素      </p>
<p>​       x = dequeue();</p>
<p>​      //得到取走一个元素之前队列的元素个数      </p>
<p>​        c = count.getAndDecrement();</p>
<p>​      //如果队列中还有数据可取，释放notEmpty条件等待队列中的第一个线程      </p>
<p>​        if (c &gt; 1)</p>
<p>​        notEmpty.signal();</p>
<p>​    } finally {</p>
<p>​      takeLock.unlock();</p>
<p>​    }</p>
<p>​    //如果队列中的元素从满到非满，通知put线程    </p>
<p>​      if (c == capacity)</p>
<p>​      signalNotFull();</p>
<p>​    return x;</p>
<p>  }</p>
</blockquote>
<h4 id="take方法总结"><a href="#take方法总结" class="headerlink" title="take方法总结:"></a>take方法总结:</h4><p>当队列为空时，就加入到notEmpty(的条件等待队列中，当队列不为空时就取走一个元素，当取完发现还有元素可取时，再通知一下自己的伙伴（等待在条件队列中的线程）；最后，如果队列从满到非满，通知一下put线程。 </p>
<h2 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h2><p>remove()方法用于删除队列中一个元素，如果队列中不含有该元素，那么返回false；有的话则删除并返回true。入队和出队都是只获取一个锁，而remove()方法需要同时获得两把锁，其实现如下：</p>
<blockquote>
<p>public boolean remove(Object o) {</p>
<p>​    //因为队列不包含null元素，返回false   </p>
<p>​     if (o == null) return false;</p>
<p>​    //获取两把锁    fullyLock();</p>
<p>​    try {</p>
<p>​      //从头的下一个节点开始遍历      </p>
<p>​      for (Node trail = head, p = trail.next;</p>
<p>​        p != null;</p>
<p>​        trail = p, p = p.next) {</p>
<p>​        //如果匹配，那么将节点从队列中移除，trail表示前驱节点        </p>
<p>​        if (o.equals(p.item)) {</p>
<p>​          unlink(p, trail);</p>
<p>​          return true;</p>
<p>​        }</p>
<p>​      }</p>
<p>​      return false;</p>
<p>​    } finally {</p>
<p>​      //释放两把锁     </p>
<p>​      fullyUnlock();</p>
<p>​    }</p>
<p>  }</p>
</blockquote>
<blockquote>
<p>void fullyLock() {</p>
<p>​    putLock.lock();</p>
<p>​    takeLock.lock();</p>
<p>  }</p>
</blockquote>
<h2 id="提问：为什么remove-方法同时需要两把锁"><a href="#提问：为什么remove-方法同时需要两把锁" class="headerlink" title="提问：为什么remove()方法同时需要两把锁?"></a>提问：为什么remove()方法同时需要两把锁?</h2><h2 id="LinkedBlockingQueue总结"><a href="#LinkedBlockingQueue总结" class="headerlink" title="LinkedBlockingQueue总结:"></a>LinkedBlockingQueue总结:</h2><p>LinkedBlockingQueue是允许两个线程同时在两端进行入队或出队的操作的，但一端同时只能有一个线程进行操作，这是通过两把锁来区分的；</p>
<p>为了维持底部数据的统一，引入了AtomicInteger的一个count变量，表示队列中元素的个数。count只能在两个地方变化，一个是入队的方法（可以+1），另一个是出队的方法（可以-1），而AtomicInteger是原子安全的，所以也就确保了底层队列的数据同步。 </p>
<h1 id="4-ArrayBlockingQueue源码分析"><a href="#4-ArrayBlockingQueue源码分析" class="headerlink" title="4. ArrayBlockingQueue源码分析"></a>4. ArrayBlockingQueue源码分析</h1><p>ArrayBlockingQueue底层是使用一个数组实现队列的，并且在构造ArrayBlockingQueue时需要指定容量，也就意味着底层数组一旦创建了，容量就不能改变了，因此ArrayBlockingQueue是一个容量限制的阻塞队列。因此，在队列全满时执行入队将会阻塞，在队列为空时出队同样将会阻塞。</p>
<p>ArrayBlockingQueue的重要字段有如下几个：</p>
<blockquote>
<p>​    /** The queued items */ </p>
<p>​     final Object[] items;</p>
<p>   /** Main lock guarding all access */ </p>
<p>​    final ReentrantLock lock;</p>
<p>  /** Condition for waiting takes */  </p>
<p>   private final Condition notEmpty;</p>
<p>  /** Condition for waiting puts */  </p>
<p>   private final Condition notFull;</p>
</blockquote>
<h2 id="put-E-e-方法-1"><a href="#put-E-e-方法-1" class="headerlink" title="put(E e)方法"></a>put(E e)方法</h2><p>put(E e)方法在队列不满的情况下，将会将元素添加到队列尾部，如果队列已满，将会阻塞，直到队列中有剩余空间可以插入。该方法的实现如下：</p>
<blockquote>
<p>public void put(E e) throws InterruptedException {</p>
<p>​    //检查元素是否为null，如果是，抛出NullPointerException    </p>
<p>​    checkNotNull(e);</p>
<p>​    final ReentrantLock lock = this.lock;</p>
<p>​    //加锁    </p>
<p>​    lock.lockInterruptibly();</p>
<p>​    try {</p>
<p>​      //如果队列已满，阻塞，等待队列成为不满状态      </p>
<p>​      while (count == items.length)</p>
<p>​        notFull.await();</p>
<p>​      //将元素入队      </p>
<p>​      enqueue(e);</p>
<p>​    } finally {</p>
<p>​      lock.unlock();</p>
<p>​    }</p>
<p>  }</p>
</blockquote>
<h2 id="put方法总结"><a href="#put方法总结" class="headerlink" title="put方法总结:"></a>put方法总结:</h2><p>\1. ArrayBlockingQueue不允许元素为null </p>
<p>\2. ArrayBlockingQueue在队列已满时将会调用notFull的await()方法释放锁并处于阻塞状态 </p>
<p>\3. 一旦ArrayBlockingQueue不为满的状态，就将元素入队</p>
<h2 id="E-take-方法-1"><a href="#E-take-方法-1" class="headerlink" title="E take()方法"></a><strong>E take()方法</strong></h2><p>take()方法用于取走队头的元素，当队列为空时将会阻塞，直到队列中有元素可取走时将会被释放。其实现如下：</p>
<blockquote>
<p>public E take() throws InterruptedException {</p>
<p>​    final ReentrantLock lock = this.lock;</p>
<p>​    //首先加锁    </p>
<p>​     lock.lockInterruptibly();</p>
<p>​    try {</p>
<p>​      //如果队列为空，阻塞      </p>
<p>​      while (count == 0)</p>
<p>​        notEmpty.await();</p>
<p>​      //队列不为空，调用dequeue()出队      </p>
<p>​      return dequeue();</p>
<p>​    } finally {</p>
<p>​      //释放锁      </p>
<p>​     lock.unlock();</p>
<p>​    }</p>
<p>  }</p>
</blockquote>
<h3 id="take方法总结-1"><a href="#take方法总结-1" class="headerlink" title="take方法总结:"></a>take方法总结:</h3><p>一旦获得了锁之后，如果队列为空，那么将阻塞；否则调用dequeue()出队一个元素。 </p>
<h2 id="ArrayBlockingQueue总结："><a href="#ArrayBlockingQueue总结：" class="headerlink" title="ArrayBlockingQueue总结："></a>ArrayBlockingQueue总结：</h2><p>ArrayBlockingQueue的并发阻塞是通过ReentrantLock和Condition来实现的，ArrayBlockingQueue内部只有一把锁，意味着同一时刻只有一个线程能进行入队或者出队的操作。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>在上面分析LinkedBlockingQueue的源码之后，可以与ArrayBlockingQueue做一个比较。 </p>
<h2 id="ArrayBlockingQueue："><a href="#ArrayBlockingQueue：" class="headerlink" title="ArrayBlockingQueue："></a>ArrayBlockingQueue：</h2><p>一个对象数组+一把锁+两个条件</p>
<p>入队与出队都用同一把锁</p>
<p>在只有入队高并发或出队高并发的情况下，因为操作数组，且不需要扩容，性能很高</p>
<p>采用了数组，必须指定大小，即容量有限</p>
<h2 id="LinkedBlockingQueue："><a href="#LinkedBlockingQueue：" class="headerlink" title="LinkedBlockingQueue："></a>LinkedBlockingQueue：</h2><p>一个单向链表+两把锁+两个条件</p>
<p>两把锁，一把用于入队，一把用于出队，有效的避免了入队与出队时使用一把锁带来的竞争。</p>
<p>在入队与出队都高并发的情况下，性能比ArrayBlockingQueue高很多</p>
<p>采用了链表，最大容量为整数最大值，可看做容量无限</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://palmbeach.gitee.io/2020/11/23/#%20%E4%BB%80%E4%B9%88%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%82%B2%E8%A7%82%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PALM BEACH">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/#%20%E4%BB%80%E4%B9%88%E6%98%AF%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%82%B2%E8%A7%82%E9%94%81/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-11-23 10:01:01 / Modified: 14:53:06" itemprop="dateCreated datePublished" datetime="2020-11-23T10:01:01+08:00">2020-11-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="什么是乐观锁，什么是悲观锁"><a href="#什么是乐观锁，什么是悲观锁" class="headerlink" title="什么是乐观锁，什么是悲观锁"></a>什么是乐观锁，什么是悲观锁</h1><h1 id="一、并发控制"><a href="#一、并发控制" class="headerlink" title="一、并发控制"></a>一、并发控制</h1><p>当程序中可能出现并发的情况时，就需要通过一定的手段来保证在并发情况下数据的准确性，通过这种手段保证了当前用户和其他用户一起操作时，所得到的结果和他单独操作时的结果是一样的。这种手段就叫做并发控制。并发控制的目的是保证一个用户的工作不会对另一个用户的工作产生不合理的影响。</p>
<p><strong>没有做好并发控制，就可能导致<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7e76ce65e3ad">脏读、幻读和不可重复读</a>等问题。</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7038163-a8d6ce3ed17394f5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/479/format/webp" alt="img"></p>
<p>常说的并发控制，一般都和数据库管理系统（DBMS）有关。在DBMS中的并发控制的任务，是确保在多个事务同时存取数据库中同一数据时，不破坏事务的隔离性和统一性以及数据库的统一性。</p>
<p><code>实现并发控制的主要手段大致可以分为乐观并发控制和悲观并发控制两种。</code><br>首先要明确：无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像hibernate、tair、memcache等都有类似的概念。所以，不应该拿乐观锁、悲观锁和其他的数据库锁等进行对比。</p>
<h1 id="二、悲观锁（Pessimistic-Lock）"><a href="#二、悲观锁（Pessimistic-Lock）" class="headerlink" title="二、悲观锁（Pessimistic Lock）"></a>二、悲观锁（Pessimistic Lock）</h1><p>当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”】。</p>
<p><strong>百度百科：</strong><br>悲观锁，正如其名，具有强烈的独占和排他特性。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度。因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p>
<p>之所以叫做悲观锁，是因为这是一种对数据的修改抱有悲观态度的并发控制方式。我们一般认为数据被并发修改的概率比较大，所以需要在修改之前先加锁。</p>
<p><strong>悲观锁主要分为共享锁或排他锁</strong></p>
<ul>
<li>共享锁【Shared lock】又称为读锁，简称S锁。顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</li>
<li>排他锁【Exclusive lock】又称为写锁，简称X锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据行读取和修改。</li>
</ul>
<p>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7038163-ea0875b10d5864c7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/format/webp" alt="img"></p>
<p>悲观锁</p>
<p>但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会。另外还会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。</p>
<h1 id="三、乐观锁（-Optimistic-Locking-）"><a href="#三、乐观锁（-Optimistic-Locking-）" class="headerlink" title="三、乐观锁（ Optimistic Locking ）"></a>三、乐观锁（ Optimistic Locking ）</h1><p>乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。</p>
<p><strong>百度百科：</strong><br>乐观锁机制采取了更加宽松的加锁机制。乐观锁是相对悲观锁而言，也是为了避免数据库幻读、业务处理时间过长等原因引起数据处理错误的一种机制，但乐观锁不会刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。</p>
<p>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7038163-dea06d00a74071fb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img"></p>
<p>乐观锁</p>
<p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。</p>
<h1 id="四、实现方式"><a href="#四、实现方式" class="headerlink" title="四、实现方式"></a>四、实现方式</h1><p>1️⃣悲观锁实现方式</p>
<p>悲观锁的实现，往往依靠数据库提供的锁机制。在数据库中，悲观锁的流程如下：</p>
<ol>
<li>在对记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。</li>
<li>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。</li>
<li>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。</li>
<li>期间如果有其他对该记录做修改或加排他锁的操作，都会等待解锁或直接抛出异常。</li>
</ol>
<p><strong>拿比较常用的MySql Innodb引擎举例，来说明一下在SQL中如何使用悲观锁。</strong></p>
<p>要使用悲观锁，必须关闭MySQL数据库的自动提交属性。因为MySQL默认使用autocommit模式，也就是说，当执行一个更新操作后，MySQL会立刻将结果进行提交。（sql语句：set autocommit=0）</p>
<p>以淘宝下单过程中扣减库存的需求说明一下悲观锁的使用：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7038163-6cc15e52ffa4f893.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/503/format/webp" alt="img"></p>
<p>悲观锁使用</p>
<p>以上，在对id = 1的记录修改前，先通过for update的方式进行加锁，然后再进行修改。这就是比较典型的悲观锁策略。</p>
<p>如果以上修改库存的代码发生并发，同一时间只有一个线程可以开启事务并获得id=1的锁，其它的事务必须等本次事务提交之后才能执行。这样可以保证当前的数据不会被其它事务修改。</p>
<p>上面提到，使用select…for update会把数据给锁住，不过需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。</p>
<p>2️⃣乐观锁实现方式</p>
<p>使用乐观锁就不需要借助数据库的锁机制了。</p>
<p>乐观锁的概念中其实已经阐述了它的具体实现细节。主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是CAS(Compare and Swap)。</p>
<p>CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p>
<p>比如前面的扣减库存问题，通过乐观锁可以实现如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7038163-623702054ade5d92.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/490/format/webp" alt="img"></p>
<p>乐观锁使用</p>
<p>以上，在更新之前，先查询一下库存表中当前库存数（quantity），然后在做update的时候，以库存数作为一个修改条件。当提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。</p>
<p>以上更新语句存在一个比较重要的问题，即传说中的<strong>ABA问题</strong>。</p>
<p>比如说一个线程one从数据库中取出库存数3，这时候另一个线程two也从数据库中取出库存数3，并且two进行了一些操作变成了2，然后two又将库存数变成3，这时候线程one进行CAS操作发现数据库中仍然是3，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7038163-8ca34c3adccb7ca6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img"></p>
<p>ABA</p>
<p>有一个比较好的办法可以解决ABA问题，那就是通过一个单独的可以顺序递增的version字段。改为以下方式即可：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7038163-a23fb455b893f97f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp" alt="img"></p>
<p>ABA的解决</p>
<p>乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。</p>
<p>除了version以外，还可以使用时间戳，因为时间戳天然具有顺序递增性。</p>
<p>以上SQL其实还是有一定的问题的，就是一旦遇上高并发的时候，就只有一个线程可以修改成功，那么就会存在大量的失败。对于像淘宝这样的电商网站，高并发是常有的事，总让用户感知到失败显然是不合理的。所以，还是要想办法减少乐观锁的粒度的。有一条比较好的建议，可以减小乐观锁力度，最大程度的提升吞吐率，提高并发能力！如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7038163-f176266a4a5136d6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/427/format/webp" alt="img"></p>
<p>优化</p>
<p>以上SQL语句中，如果用户下单数为1，则通过quantity - 1 &gt; 0的方式进行乐观锁控制。</p>
<p>以上update语句，在执行过程中，会在一次原子操作中自己查询一遍quantity的值，并将其扣减掉1。</p>
<p>高并发环境下锁粒度把控是一门重要的学问，选择一个好的锁，在保证数据安全的情况下，可以大大提升吞吐率，进而提升性能。</p>
<h1 id="五、如何选择"><a href="#五、如何选择" class="headerlink" title="五、如何选择"></a>五、如何选择</h1><p>在乐观锁与悲观锁的选择上面，主要看下两者的区别以及适用场景就可以了。</p>
<ol>
<li>乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。</li>
<li>悲观锁依赖数据库锁，效率低。更新失败的概率比较低。</li>
</ol>
<p>随着互联网三高架构（高并发、高性能、高可用）的提出，悲观锁已经越来越少的被应用到生产环境中了，尤其是并发量比较大的业务场景。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://palmbeach.gitee.io/2020/11/23/#%20Spring%20SmartLifecycle%20%E5%9C%A8%E5%AE%B9%E5%99%A8%E6%89%80%E6%9C%89bean%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%8C%E6%AF%95%E6%89%A7%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PALM BEACH">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/#%20Spring%20SmartLifecycle%20%E5%9C%A8%E5%AE%B9%E5%99%A8%E6%89%80%E6%9C%89bean%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%8C%E6%AF%95%E6%89%A7%E8%A1%8C/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-11-23 10:01:01 / Modified: 14:53:12" itemprop="dateCreated datePublished" datetime="2020-11-23T10:01:01+08:00">2020-11-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring-SmartLifecycle-在容器所有bean加载和初始化完毕执行"><a href="#Spring-SmartLifecycle-在容器所有bean加载和初始化完毕执行" class="headerlink" title="Spring SmartLifecycle 在容器所有bean加载和初始化完毕执行"></a>Spring SmartLifecycle 在容器所有bean加载和初始化完毕执行</h1><p><img src="https://csdnimg.cn/release/phoenix/template/new_img/original.png" alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://me.csdn.net/catoop">catoop</a> 2017-05-06 17:52:17 <img src="https://csdnimg.cn/release/phoenix/template/new_img/articleReadEyes.png" alt="img"> 16684 <img src="https://csdnimg.cn/release/phoenix/template/new_img/tobarCollect.png" alt="img"> 收藏 5</p>
<p>分类专栏： <a target="_blank" rel="noopener" href="https://blog.csdn.net/catoop/category_5789635.html">Spring</a> 文章标签： <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search/s.do?q=spring&t=blog&o=vip&s=&l=&f=&viparticle=">spring</a></p>
<p>版权</p>
<p>在使用Spring开发时，我们都知道，所有bean都交给Spring容器来统一管理，其中包括没一个bean的加载和初始化。<br>有时候我们需要在Spring加载和初始化所有bean后，接着执行一些任务或者启动需要的异步服务，这样我们可以使用 SmartLifecycle 来做到。</p>
<p>SmartLifecycle 是一个接口。当Spring容器加载所有bean并完成初始化之后，会接着回调实现该接口的类中对应的方法（start()方法）。<br>如下是一个实例：<br>我在对应的方法上注上了明确的说明，注意看一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">package com.shanhy.sboot;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.SmartLifecycle;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * SmartLifecycle测试</span><br><span class="line"> *</span><br><span class="line"> * @author 单红宇(CSDN CATOOP)</span><br><span class="line"> * @create 2017年5月6日</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">public class TestSmartLifecycle implements SmartLifecycle &#123;</span><br><span class="line"></span><br><span class="line">    private boolean isRunning &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 1. 我们主要在该方法中启动任务或者其他异步服务，比如开启MQ接收消息&lt;br&#x2F;&gt;</span><br><span class="line">     * 2. 当上下文被刷新（所有对象已被实例化和初始化之后）时，将调用该方法，默认生命周期处理器将检查每个SmartLifecycle对象的isAutoStartup()方法返回的布尔值。</span><br><span class="line">     * 如果为“true”，则该方法会被调用，而不是等待显式调用自己的start()方法。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;start&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 执行完其他业务后，可以修改 isRunning &#x3D; true</span><br><span class="line">        isRunning &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 如果工程中有多个实现接口SmartLifecycle的类，则这些类的start的执行顺序按getPhase方法返回值从小到大执行。&lt;br&#x2F;&gt;</span><br><span class="line">     * 例如：1比2先执行，-1比0先执行。 stop方法的执行顺序则相反，getPhase返回值较大类的stop方法先被调用，小的后被调用。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public int getPhase() &#123;</span><br><span class="line">        &#x2F;&#x2F; 默认为0</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 根据该方法的返回值决定是否执行start方法。&lt;br&#x2F;&gt; </span><br><span class="line">     * 返回true时start方法会被自动执行，返回false则不会。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAutoStartup() &#123;</span><br><span class="line">        &#x2F;&#x2F; 默认为false</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 1. 只有该方法返回false时，start方法才会被执行。&lt;br&#x2F;&gt;</span><br><span class="line">     * 2. 只有该方法返回true时，stop(Runnable callback)或stop()方法才会被执行。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean isRunning() &#123;</span><br><span class="line">        &#x2F;&#x2F; 默认返回false</span><br><span class="line">        return isRunning;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * SmartLifecycle子类的才有的方法，当isRunning方法返回true时，该方法才会被调用。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void stop(Runnable callback) &#123;</span><br><span class="line">        System.out.println(&quot;stop(Runnable)&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果你让isRunning返回true，需要执行stop这个方法，那么就不要忘记调用callback.run()。</span><br><span class="line">        &#x2F;&#x2F; 否则在你程序退出时，Spring的DefaultLifecycleProcessor会认为你这个TestSmartLifecycle没有stop完成，程序会一直卡着结束不了，等待一定时间（默认超时时间30秒）后才会自动结束。</span><br><span class="line">        &#x2F;&#x2F; PS：如果你想修改这个默认超时时间，可以按下面思路做，当然下面代码是springmvc配置文件形式的参考，在SpringBoot中自然不是配置xml来完成，这里只是提供一种思路。</span><br><span class="line">        &#x2F;&#x2F; &lt;bean id&#x3D;&quot;lifecycleProcessor&quot; class&#x3D;&quot;org.springframework.context.support.DefaultLifecycleProcessor&quot;&gt;</span><br><span class="line">        &#x2F;&#x2F;      &lt;!-- timeout value in milliseconds --&gt;</span><br><span class="line">        &#x2F;&#x2F;      &lt;property name&#x3D;&quot;timeoutPerShutdownPhase&quot; value&#x3D;&quot;10000&quot;&#x2F;&gt;</span><br><span class="line">        &#x2F;&#x2F; &lt;&#x2F;bean&gt;</span><br><span class="line">        callback.run();</span><br><span class="line"></span><br><span class="line">        isRunning &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 接口Lifecycle的子类的方法，只有非SmartLifecycle的子类才会执行该方法。&lt;br&#x2F;&gt;</span><br><span class="line">     * 1. 该方法只对直接实现接口Lifecycle的类才起作用，对实现SmartLifecycle接口的类无效。&lt;br&#x2F;&gt;</span><br><span class="line">     * 2. 方法stop()和方法stop(Runnable callback)的区别只在于，后者是SmartLifecycle子类的专属。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Override</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        System.out.println(&quot;stop&quot;);</span><br><span class="line"></span><br><span class="line">        isRunning &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://palmbeach.gitee.io/2020/11/23/%E4%B8%80.%20%E4%BB%80%E4%B9%88%E6%98%AFRestTemplate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PALM BEACH">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/%E4%B8%80.%20%E4%BB%80%E4%B9%88%E6%98%AFRestTemplate/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-11-23 10:01:01 / Modified: 14:53:06" itemprop="dateCreated datePublished" datetime="2020-11-23T10:01:01+08:00">2020-11-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="一-什么是RestTemplate"><a href="#一-什么是RestTemplate" class="headerlink" title="一. 什么是RestTemplate"></a>一. 什么是RestTemplate</h3><p>传统情况下在java代码里访问restful服务，一般使用<code>Apache</code>的<code>HttpClient</code>。不过此种方法使用起来太过繁琐。spring提供了一种简单便捷的模板类来进行操作，这就是<code>RestTemplate</code>。</p>
<h3 id="二-一个简单的例子。"><a href="#二-一个简单的例子。" class="headerlink" title="二.一个简单的例子。"></a>二.一个简单的例子。</h3><p>定义一个简单的restful接口</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = <span class="meta-string">&quot;testPost&quot;</span>, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseBean testPost(<span class="meta">@RequestBody</span> RequestBean requestBean)</span><br><span class="line">    &#123;</span><br><span class="line">        ResponseBean responseBean = new ResponseBean();</span><br><span class="line">        responseBean.setRetCode(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        responseBean.setRetMsg(<span class="string">&quot;succ&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> responseBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>RestTemplate</code>访问该服务</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求地址</span></span><br><span class="line"><span class="built_in">String</span> url = <span class="string">&quot;http://localhost:8080/testPost&quot;</span>;</span><br><span class="line"><span class="comment">//入参</span></span><br><span class="line">RequestBean requestBean = <span class="keyword">new</span> RequestBean();</span><br><span class="line">requestBean.setTest1(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">requestBean.setTest2(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">requestBean.setTest3(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">ResponseBean responseBean = restTemplate.postForObject(url, requestBean, ResponseBean.<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure>

<p>从这个例子可以看出，使用<code>restTemplate</code>访问restful接口非常的<strong>简单粗暴无脑</strong>。<code>(url, requestMap, ResponseBean.class)</code>这三个参数分别代表 请求地址、请求参数、HTTP响应转换被转换成的对象类型。</p>
<p>RestTemplate方法的名称遵循命名约定，第一部分指出正在调用什么HTTP方法，第二部分指示返回的内容。本例中调用了<code>restTemplate.postForObject</code>方法，<code>post</code>指调用了HTTP的post方法，<code>Object</code>指将HTTP响应转换为您选择的<strong>对象类型</strong>。还有其他很多类似的方法，有兴趣的同学可以<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-framework/docs/4.3.7.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html">参考官方api</a>。</p>
<h3 id="三-手动指定转换器-HttpMessageConverter"><a href="#三-手动指定转换器-HttpMessageConverter" class="headerlink" title="三.手动指定转换器(HttpMessageConverter)"></a>三.手动指定转换器(HttpMessageConverter)</h3><p>我们知道，调用reseful接口传递的数据内容是json格式的字符串，返回的响应也是json格式的字符串。然而<code>restTemplate.postForObject</code>方法的请求参数<code>RequestBean</code>和返回参数<code>ResponseBean</code>却都是java类。是<code>RestTemplate</code>通过<code>HttpMessageConverter</code>自动帮我们做了转换的操作。</p>
<p>默认情况下<code>RestTemplate</code>自动帮我们注册了一组<code>HttpMessageConverter</code>用来处理一些不同的<code>contentType</code>的请求。<br>如<code>StringHttpMessageConverter</code>来处理<code>text/plain</code>;<code>MappingJackson2HttpMessageConverter</code>来处理<code>application/json</code>;<code>MappingJackson2XmlHttpMessageConverter</code>来处理<code>application/xml</code>。<br>你可以在<code>org.springframework.http.converter</code>包下找到所有spring帮我们实现好的转换器。<br>如果现有的转换器不能满足你的需求，你还可以实现<code>org.springframework.http.converter.HttpMessageConverter</code>接口自己写一个。详情<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-framework/docs/4.3.7.RELEASE/javadoc-api/org/springframework/http/converter/package-summary.html">参考官方api</a>。</p>
<p>选好了<code>HttpMessageConverter</code>后怎么把它注册到我们的<code>RestTemplate</code>中呢。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line"><span class="comment">//获取RestTemplate默认配置好的所有转换器</span></span><br><span class="line">List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = restTemplate.getMessageConverters();</span><br><span class="line"><span class="comment">//默认的MappingJackson2HttpMessageConverter在第7个 先把它移除掉</span></span><br><span class="line">messageConverters.<span class="keyword">remove</span>(<span class="number">6</span>);</span><br><span class="line"><span class="comment">//添加上GSON的转换器</span></span><br><span class="line">messageConverters.<span class="keyword">add</span>(<span class="number">6</span>, <span class="keyword">new</span> GsonHttpMessageConverter());</span><br></pre></td></tr></table></figure>

<p>这个简单的例子展示了如何使用<code>GsonHttpMessageConverter</code>替换掉默认用来处理<code>application/json</code>的<code>MappingJackson2HttpMessageConverter</code>。</p>
<h3 id="四-设置底层连接方式"><a href="#四-设置底层连接方式" class="headerlink" title="四.设置底层连接方式"></a>四.设置底层连接方式</h3><p>要创建一个<code>RestTemplate</code>的实例，您可以像上述例子中简单地调用默认的无参数构造函数。这将使用<code>java.net</code>包中的标准Java类作为底层实现来创建HTTP请求。<br>但很多时候我们需要像传统的<code>HttpClient</code>那样设置HTTP请求的一些属性。<code>RestTemplate</code>使用了一种很偷懒的方式实现了这个需求，那就是直接使用一个<code>HttpClient</code>作为底层实现……</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成一个设置了连接超时时间、请求超时时间、异常最大重试次数的httpClient</span></span><br><span class="line">RequestConfig config = RequestConfig.custom().setConnectionRequestTimeout(<span class="number">10000</span>).setConnectTimeout(<span class="number">10000</span>).setSocketTimeout(<span class="number">30000</span>).build();</span><br><span class="line">HttpClientBuilder builder = HttpClientBuilder.create().setDefaultRequestConfig(config).setRetryHandler(<span class="keyword">new</span> DefaultHttpRequestRetryHandler(<span class="number">5</span>, <span class="literal">false</span>));</span><br><span class="line">HttpClient httpClient = builder.build();</span><br><span class="line"><span class="comment">//使用httpClient创建一个ClientHttpRequestFactory的实现</span></span><br><span class="line">ClientHttpRequestFactory requestFactory = <span class="keyword">new</span> HttpComponentsClientHttpRequestFactory(httpClient);</span><br><span class="line"> <span class="comment">//ClientHttpRequestFactory作为参数构造一个使用作为底层的RestTemplate</span></span><br><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate(requestFactory);</span><br></pre></td></tr></table></figure>

<h3 id="五-设置拦截器-ClientHttpRequestInterceptor"><a href="#五-设置拦截器-ClientHttpRequestInterceptor" class="headerlink" title="五.设置拦截器(ClientHttpRequestInterceptor)"></a>五.设置拦截器(ClientHttpRequestInterceptor)</h3><p>有时候我们需要对请求做一些通用的拦截设置，这就可以使用拦截器进行处理。拦截器需要我们实现<code>org.springframework.http.client.ClientHttpRequestInterceptor</code>接口自己写。</p>
<p>举个简单的例子，写一个在header中根据请求内容和地址添加令牌的拦截器。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TokenInterceptor</span> <span class="keyword">implements</span> <span class="title">ClientHttpRequestInterceptor</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//请求地址</span></span><br><span class="line">        <span class="built_in">String</span> checkTokenUrl = request.getURI().getPath();</span><br><span class="line">        <span class="comment">//token有效时间</span></span><br><span class="line">        <span class="built_in">int</span> ttTime = (<span class="built_in">int</span>) (System.currentTimeMillis() / <span class="number">1000</span> + <span class="number">1800</span>);</span><br><span class="line">        <span class="comment">//请求方法名 POST、GET等</span></span><br><span class="line">        <span class="built_in">String</span> methodName = request.getMethod().name();</span><br><span class="line">        <span class="comment">//请求内容</span></span><br><span class="line">        <span class="built_in">String</span> requestBody = <span class="keyword">new</span> <span class="built_in">String</span>(body);</span><br><span class="line">        <span class="comment">//生成令牌 此处调用一个自己写的方法，有兴趣的朋友可以自行google如何使用ak/sk生成token，此方法跟本教程无关，就不贴出来了</span></span><br><span class="line">        <span class="built_in">String</span> token = TokenHelper.generateToken(checkTokenUrl, ttTime, methodName, requestBody);</span><br><span class="line">        <span class="comment">//将令牌放入请求header中</span></span><br><span class="line">        request.getHeaders().add(<span class="string">&quot;X-Auth-Token&quot;</span>,token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> execution.execute(request, body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建<code>RestTemplate</code>实例的时候可以这样向其中添加拦截器</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line"><span class="comment">//向restTemplate中添加自定义的拦截器</span></span><br><span class="line">restTemplate.getInterceptors().<span class="keyword">add</span>(<span class="keyword">new</span> TokenInterceptor());</span><br></pre></td></tr></table></figure>

<h3 id="六-总结"><a href="#六-总结" class="headerlink" title="六.总结"></a>六.总结</h3><p>通过本章的讲解，想必读者初步的了解了如何使用<code>RestTemplate</code>方便快捷的访问restful接口。其实<code>RestTemplate</code>的功能非常强大，作者也仅仅学了点皮毛。如果大家觉得本文有什么地方没写清楚的或者有其他什么想要了解的可以在下方留言，我后续会尽量在文中进行补充完善。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://palmbeach.gitee.io/2020/11/23/%E4%BD%BF%E7%94%A8Mapstruct%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%AE%9E%E4%BD%93%E4%B8%8E%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PALM BEACH">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/%E4%BD%BF%E7%94%A8Mapstruct%E6%9D%A5%E8%BF%9B%E8%A1%8C%E5%AE%9E%E4%BD%93%E4%B8%8E%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2020-11-23 10:01:01 / Modified: 14:53:06" itemprop="dateCreated datePublished" datetime="2020-11-23T10:01:01+08:00">2020-11-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="使用Mapstruct来进行实体与模型之间的映射操作"><a href="#使用Mapstruct来进行实体与模型之间的映射操作" class="headerlink" title="使用Mapstruct来进行实体与模型之间的映射操作"></a>使用Mapstruct来进行实体与模型之间的映射操作</h1><p>在一个成熟可维护的工程中，细分模块后，domian工程最好不要被其他工程依赖，但是实体类一般存于domain之中，这样其他工程想获取实体类数据时就需要在各自工程写model，自定义model可以根据自身业务需要而并不需要映射整个实体属性。</p>
<p>  mapstruct这个插件就是用来处理domin实体类与model类的属性映射，定义mapper接口，mapstruct就会自动的帮我们实现这个映射接口，避免了麻烦复杂的映射实现。</p>
<p>  工程中引入mapstruct依赖</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mapstruct --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-jdk8<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;org.mapstruct.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>这里定义实体Person</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<p>这里定义模型PersonModel </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonModel</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="keyword">private</span> String phone; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义实体Person与模型PersonModel,这里两个类的属性一致。</p>
<p>定义映射可以使用接口也可以使用静态类。</p>
<p>&lt;1&gt;使用接口映射：</p>
<p>    <a>简单实体映射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonMapper</span> </span>&#123;</span><br><span class="line">    PersonMapper INSTANCE = Mappers.getMapper(PersonMapper.class);</span><br><span class="line">    <span class="function">PersonModel <span class="title">map</span><span class="params">( Person entity)</span></span>;</span><br><span class="line">    List&lt;PersonModel &gt; map(List&lt; Person&gt; entity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里在PersonMapper 定义了两个map方法，第一个是单实体映射，第二个方法是List映射。在存盘之后，mapstruct会自动在target文件里为我们实现我们定义的映射接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Generated(</span></span><br><span class="line"><span class="meta">    value = &quot;org.mapstruct.ap.MappingProcessor&quot;,</span></span><br><span class="line"><span class="meta">    date = &quot;2017-01-18T11:53:32+0800&quot;,</span></span><br><span class="line"><span class="meta">    comments = &quot;version: 1.0.0.Final, compiler: Eclipse JDT (IDE) 1.2.0.v20150514-0146, environment: Java 1.8.0_31 (Oracle Corporation)&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonMapperImpl</span> <span class="keyword">implements</span> <span class="title">PersonMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersonModel <span class="title">ma</span><span class="params">(Person entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( entity == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        PersonModel personModel = <span class="keyword">new</span> PersonModel();</span><br><span class="line">        personModel.setName( entity.getName() );</span><br><span class="line">        personModel.setAge( entity.getAge() );</span><br><span class="line">        personModel.setPhone( entity.gePhone() );</span><br><span class="line">        <span class="keyword">return</span> personModel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;PersonModel&gt; <span class="title">map</span><span class="params">(List&lt;Person&gt; entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( entity == <span class="keyword">null</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;PersonModel&gt; list = <span class="keyword">new</span> ArrayList&lt;PersonModel&gt;();</span><br><span class="line">        <span class="keyword">for</span> ( Person person : entity ) &#123;</span><br><span class="line">            list.add( map( person) );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在目标工程使用实体的时候只需要new一个PersonMapper的实例INSTANCE，就可以调用map()方法映射实体属性到模型中去了。<br>  但是这是在实体与模型的属性命名一致的情况下，这种情况下映射基本上不需要我们指定模型的哪个属性对应实体的哪个属性，在模型属性命名与实体属性命名不一致的情况下，还可以使用@Mapping(target = “模型属性”, source = “实体属性”)来指定的映射某个属性<br>  重新定义PersonModel跟Person<br>  这里定义实体Person</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="keyword">private</span> String phone; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这里定义模型PersonModel </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonModel</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String personName;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="keyword">private</span> String phone;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>其中将PersonModel中的name属性改为personName，这里的映射接口写法就可以写成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonMapper</span> </span>&#123;</span><br><span class="line">    PersonMapper INSTANCE = Mappers.getMapper(PersonMapper.class);</span><br><span class="line">    <span class="meta">@Mapping(target = &quot;personName&quot;, source = &quot;name&quot;)</span></span><br><span class="line">    <span class="function">PersonModel <span class="title">map</span><span class="params">( Person entity)</span></span>;</span><br><span class="line">    List&lt;PersonModel &gt; map(List&lt; Person&gt; entity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果model定义了在实体没有可以映射的属性时，就可以使用@Mapping(target = “模型属性”, ignore = true)来跳过不需要映射的模型属性了。</p>
<p>  如下面重新定义实体Person和模型PersonModel</p>
<p>  这里定义实体Person</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String phone;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>这里定义模型PersonModel </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonModel</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String personName; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line">    <span class="keyword">private</span> String phone;  </span><br><span class="line">    <span class="keyword">private</span> String hand;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p> 这里的映射接口就应该改为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    PersonMapper INSTANCE = Mappers.getMapper(PersonMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping(target = &quot;personName&quot;, source = &quot;name&quot;)</span></span><br><span class="line">    <span class="meta">@Mapping(target = &quot;hand&quot;,  ignore = true)</span></span><br><span class="line"></span><br><span class="line">    <span class="function">PersonModel <span class="title">map</span><span class="params">( Person entity)</span></span>;</span><br><span class="line">    List&lt;PersonModel &gt; map(List&lt; Person&gt; entity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 如果模型与实体均存在很多属性的情况下，映射接口的@Mapping注解很容易写得很长，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonMapper</span> </span>&#123;</span><br><span class="line">    PersonMapper INSTANCE = Mappers.getMapper(PersonMapper.class);</span><br><span class="line">    <span class="meta">@Mapping(target = &quot;personName&quot;, source = &quot;name&quot;)</span></span><br><span class="line">    <span class="meta">@Mapping(target = &quot;hand&quot;,  ignore = true)</span></span><br><span class="line">     ..</span><br><span class="line">     ..</span><br><span class="line">     ..</span><br><span class="line">     ..</span><br><span class="line">    <span class="function">PersonModel <span class="title">map</span><span class="params">( Personentity)</span></span>;</span><br><span class="line">    List&lt;PersonModel &gt; map(List&lt; Person&gt; entity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p> 这样的程序就不可避免的写得很笨了。所以我们也可以使用default默认方法来定义映射接口，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonMapper</span> </span>&#123;</span><br><span class="line">    PersonMapper INSTANCE = Mappers.getMapper(PersonMapper.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping(target = &quot;hand&quot;,  ignore = true)</span></span><br><span class="line">    <span class="function">PersonModel <span class="title">map</span><span class="params">(Person entity, Person personName, Person age, Person phone)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> PersonModel <span class="title">map</span><span class="params">(Person entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE.map(entity, entity.getName(), entity.getAge(), entity.getPhone());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">List&lt;PersonModel&gt; <span class="title">map</span><span class="params">(List&lt;Person&gt; entity)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>&lt;2&gt;使用静态类映射实体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper(componentModel = &quot;spring&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PesonMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Mapping(target = &quot;personName&quot;, source = &quot;name&quot;)</span></span><br><span class="line">   <span class="meta">@Mapping(target = &quot;hand&quot;,  ignore = true)</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> PersonModel <span class="title">map</span><span class="params">( Person entity)</span></span>;</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">abstract</span>  List&lt;PersonModel &gt; map(List&lt; Person&gt; entity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p> 虽然看起来写法差不多一直，但是使用静态类来映射有他的好处，最起码接口只能定义方法，无法写方法体，但是使用了静态类，就可以写上方法体了，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper(componentModel = &quot;spring&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PesonMapper</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> PersonModel <span class="title">mapEighteen</span><span class="params">( Person entity)</span> </span>&#123;</span><br><span class="line">	  <span class="keyword">if</span> (entity.getName.equals(<span class="number">18</span>)) &#123;</span><br><span class="line">		   <span class="keyword">return</span> map(entity);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="meta">@Mapping(target = &quot;personName&quot;, source = &quot;name&quot;)</span></span><br><span class="line">   <span class="meta">@Mapping(target = &quot;hand&quot;,  ignore = true)</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> PersonModel <span class="title">map</span><span class="params">( Person entity)</span></span>;</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">abstract</span>  List&lt;PersonModel &gt; map(List&lt; Person&gt; entity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>调用mapEighteen()就可以只映射实体属性age为18的实体了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  


















  








  

  

</body>
</html>
